## 泛型编程的优点
 1. 泛型编程的好处：可以被不同对象重用，编译器可以检查，避免插入错误类型。程序具有更好的可读性和安全性
 2. T :类型参数
 
 ---
 ##泛型类
 1. 泛型类可定义一个或多个类型变量
 2. 作用域：方法返回值，局部变量，成员变量
 3. 类型变量一般用大写标识，E：集合元素；K  V 表示键值对；T ：表示任意类型
 4. 泛型类可以看做普通类的工厂
 5. 泛型类案例参考jdk
 
 ---
 ##泛型方
 1. 类型变量位置：修饰符之后，返回值类型之前
 2. 泛型方法可以定义来普通陪，也可以定义在泛型类
 3. 更多泛型方法参考java集合类
 
 ---
 ##泛型约束
 1. 不能使用基本数据类型实例化类型变量，原因：类型擦除，如果类型变量没有约束，则类型擦除后为Object类型的域，Object不能
     存储基本数据类型。
 2. 运行时类型查询只适用于原始类型，原因：带有泛型的对象在运行时由于类型擦除，他和原始类型形同。所以在运行时判断
 类型，执行判断原始类型。例如if(a instanceof Persion<String>) 错误。if(a instanceof Persion) 正确。再例如
 List<String>.class和List.class他们二者本质相同，不存在List<String>
 
 3. 不能参数化数组Student<String>[] student = new Student<String>[10],但是可以声明通赔类型数组，
 然后强制类型转换：Student<String>[] student = (Student<String>[])new Student[10]
 
 4. 泛型类的静态上限文中类型变量无效
    1. 不能使一个静态引用指向一个非静态的类型 T。静态和非静态之分就在于静态是编译时类型，
 动态是运行时类型。
    2. T代表未知类型，如果可以用于静态申明，因为是未知类型，系统没法指定初始值，手动赋值也不行，因为不知道啥类型，只有运行时才可以指定。
    3. 而泛型存在的意义就是为了动态指定具体类型，增强灵活性和通用性，所以用于静态声明违背了使用原则

 ---
 ## 不能实例化类型变量
 1. 例如 new T();T.class,在类型擦除后T变为Object，但我们的本意肯定不是调用Object
 
 ---
 ##消除受检查异常
 1. 什么是受检查异常？
 
 ---
 ##通配符类型
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 